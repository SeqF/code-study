package sort;

/**
 * 计数排序
 *
 * @author paksu
 */
public class CountingSort {

    /**
     * 计数排序其实是桶排序的一种特殊情况（即桶的大小为1）。当要排序的n个数据所处的范围并不大时，比如最大值是K，就可以
     * 把数据划分为K个桶，每个桶内的数据都是相同的，省掉了桶内排序的时间
     * <p>
     * 数组a：原始数据
     * 数组c：存放数组a中各个数据所对应的出现次数，依次求和后变为对应下标（数据）所在的位置
     * 数组r: 通过数组c中存放的数据次数来推断，存放排序后的数组
     * <p>
     * 计数排序只能用在数据范围不大的场景中(即最大、最小值相差不太大）,如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
     * 而且，计数排序只能给非负整数排序
     * <p>
     * 时间复杂度为O（n），即线性排序，是非基于比较的排序算法
     */
    public void countingSort(int[] a, int n) {
        if (n < 1) {
            return;
        }

        //查找数组中数据的范围
        int max = a[0];
        for (int i = 0; i < n; i++) {
            if (max < a[i]) {
                max = a[i];
            }
        }

        //申请一个计数数组c，下标大小[0,max]
        int[] c = new int[max + 1];
        for (int i = 0; i <= max; i++) {
            c[i] = 0;
        }

        //计算每个元素的个数,放入c中
        for (int i = 0; i < n; i++) {
            c[a[i]]++;
        }

        //将数组c依次累加
        for (int i = 0; i <= max; i++) {
            c[i] = c[i - 1] + c[i];
        }

        //临时数组r，存储排序之后的结果
        int[] r = new int[n];
        //计算排序的关键步骤，反向遍历a数组
        // c数组中，下标为元素值（即a[i]），值为元素个数(即r数组中对应元素的位置）
        for (int i = n - 1; i > 0; i--) {
            int index = c[a[i]] - 1;
            r[index] = a[i];
            c[a[i]]--;
        }

        //将结果拷贝给a数组
        for (int i = 0; i < n; i++) {
            a[i] = r[i];
        }
    }
}
